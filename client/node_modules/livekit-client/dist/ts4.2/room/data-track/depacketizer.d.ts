import type { Throws } from '../../utils/throws';
import { LivekitReasonedError } from '../errors';
import type { DataTrackFrame } from './frame';
import { DataTrackPacket } from './packet';
/** An error indicating a frame was dropped. */
export declare class DataTrackDepacketizerDropError<Reason extends DataTrackDepacketizerDropReason> extends LivekitReasonedError<Reason> {
    readonly name = "DataTrackDepacketizerDropError";
    reason: Reason;
    reasonName: string;
    frameNumber: number;
    constructor(message: string, reason: Reason, frameNumber: number, options?: {
        cause?: unknown;
    });
    static interrupted(frameNumber: number): DataTrackDepacketizerDropError<DataTrackDepacketizerDropReason.Interrupted>;
    static unknownFrame(frameNumber: number): DataTrackDepacketizerDropError<DataTrackDepacketizerDropReason.UnknownFrame>;
    static bufferFull(frameNumber: number): DataTrackDepacketizerDropError<DataTrackDepacketizerDropReason.BufferFull>;
    static incomplete(frameNumber: number, receivedPackets: number, expectedPackets: number): DataTrackDepacketizerDropError<DataTrackDepacketizerDropReason.Incomplete>;
}
/** Reason why a frame was dropped. */
export declare enum DataTrackDepacketizerDropReason {
    Interrupted = 0,
    UnknownFrame = 1,
    BufferFull = 2,
    Incomplete = 3
}
type PushOptions = {
    /** If true, throws an error instead of logging a warning when a new frame is encountered half way
     * through processing a pre-existing frame. */
    errorOnPartialFrames: boolean;
};
export declare class DataTrackDepacketizer {
    /** Maximum number of packets to buffer per frame before dropping. */
    static MAX_BUFFER_PACKETS: number;
    private partial;
    /** Should be repeatedly called with received {@link DataTrackPacket}s - intermediate calls
     * aggregate the packet's state internally, and return null.
     *
     * Once this method is called with the final packet to form a frame, a new {@link DataTrackFrame}
     * is returned.*/
    push(packet: DataTrackPacket, options?: PushOptions): Throws<DataTrackFrame | null, DataTrackDepacketizerDropError<DataTrackDepacketizerDropReason.Interrupted> | DataTrackDepacketizerDropError<DataTrackDepacketizerDropReason.BufferFull> | DataTrackDepacketizerDropError<DataTrackDepacketizerDropReason.UnknownFrame> | DataTrackDepacketizerDropError<DataTrackDepacketizerDropReason.Incomplete>>;
    reset(): void;
    private frameFromSingle;
    /** Begin assembling a new packet. */
    private beginPartial;
    /** Push to the existing partial frame. */
    private pushToPartial;
    /** Try to reassemble the complete frame. */
    private finalize;
}
export {};
//# sourceMappingURL=depacketizer.d.ts.map
