import type { Throws } from '../../utils/throws';
import { LivekitReasonedError } from '../errors';
import type { DataTrackFrame } from './frame';
import { DataTrackHandle } from './handle';
import { DataTrackPacket, FrameMarker } from './packet';
import { DataTrackTimestamp } from './utils';
type PacketizeOptions = {
    /** "now" timestamp to use as a base when generating new packet timestamps. If not specified,
     * defaults to the return value of {@link DataTrackClock#now}. */
    now?: DataTrackTimestamp<90000>;
};
export declare class DataTrackPacketizerError<Reason extends DataTrackPacketizerReason> extends LivekitReasonedError<Reason> {
    readonly name = "DataTrackPacketizerError";
    reason: Reason;
    reasonName: string;
    constructor(message: string, reason: Reason, options?: {
        cause?: unknown;
    });
    static mtuTooShort(): DataTrackPacketizerError<DataTrackPacketizerReason>;
}
export declare enum DataTrackPacketizerReason {
    MtuTooShort = 0
}
/** A packetizer takes a {@link DataTrackFrame} as input and generates a series
 * of {@link DataTrackPacket}s for transmission to other clients over webrtc. */
export declare class DataTrackPacketizer {
    private handle;
    private mtuSizeBytes;
    private sequence;
    private frameNumber;
    private clock;
    constructor(trackHandle: DataTrackHandle, mtuSizeBytes: number);
    /** @internal */
    static computeFrameMarker(index: number, packetCount: number): FrameMarker;
    /** Generates a series of packets for the specified {@link DataTrackPacketizerFrame}.
     *
     * NOTE: The return value of this function is a generator, so it can be lazily ran if desired,
     * or converted to an array with {@link Array.from}.
     */
    packetize(frame: DataTrackFrame, options?: PacketizeOptions): Throws<Generator<DataTrackPacket>, DataTrackPacketizerError<DataTrackPacketizerReason.MtuTooShort>>;
}
export {};
//# sourceMappingURL=packetizer.d.ts.map
